https://www.exploit-db.com/papers/23985


Nickel c'est ce qu'on attendait. Quelques clarifications. On utilise `echo $'chain'` pour traduire nos
octets hexadecimaux ('\x**') en charactères transmissible à ./formatstring. Ensuite, dans la fonction printf, 
%141$n essaie d'écrire à l'addresse présente sur la pile à l'offset 141, qui s'avère être notre addresse 
transmise, soit 0x0804a004. %141$n écrit donc le nombre de caractères présent avant lui dans argv[1], soit 0x6 à 
l'adresse 0x0804a004. Et 2 instructions plus tard, quand le programme va consulter l'addresse de putchar dans 
la GOT, il assigne à l'EIP la valeur *0x0804a004, qui est désormais 0x00000006 et le programme crash 

......

Comment controler la valeur que nous écrivons? Souvenez vous de la definition du modifier %n/%hn, on peut 
utiliser des 'A' (ca risque de faire beaucoup...) ou alors le modifier %500x pour écrire 500 octets par 
exemple. La méthode des %***x abouti à l'exploit le plus court, c'est celle que nous allons utiliser.
N'oublions pas, pour chaque ajout de %***x on devra compléter par un ajout de 16-strlen('%***x') nombre 
de 'A' a la fin de l'argument pour que l'addresse de base de argv[1] sur la pile de printf reste la meme
(toujours la même règle).
